==============================================================
Level 1: アプリケーションをコンテナ化する
==============================================================

今回はコンテナに適したアーキテクチャへ変更するまえの段階として、
オンプレミスで仮想マシンで動いているアプリケーションについてコンテナ化をしていきます。

このレベルで習得できるもの
=============================================================

* 一般的なコンテナイメージの作成の手法 (Docker image)
* デプロイメント方法の習得

コンテナ化の準備
=============================================================

本ラボでは以下のイメージをキャッシュしているのでイメージのpullが高速になります。

Web/AP レイヤー

* nginx
* apache
* tomcat

Databaseレイヤー

* mySQL
* Postgress
* Oracle
* MongoDB

コンテナイメージの作成
=============================================================

想定するアプリケーションのコンテナイメージを作成します。

Dockerfile のリファレンス `Dockerfile Reference ファイル <https://docs.docker.com/engine/reference/builder/>`_


留意点としては以下の通りです。

* アプリケーションの配置をDockerfile内に配置
* 基本となるコンテナイメージについてはDockerHubで探してベースイメージとする
* 静的な構成となっていないか(IPパスワードのべた書きなど)

    * 環境変数で設定出来るよう設計する。のちほどk8sのSecretなどでパスワードを保存

* 冪等性はコンテナイメージ側で対応する。責任範囲を明確にしてイメージを作成
* ステートフルなものについてはコンテナに適したものにする

    * データ永続化については :doc:`../Level2/index` にて実施

.. hint::

    どうしても進まない場合は :doc:`resources/level1_sampledockerfile`  をクリックしてください。


コンテナイメージのビルド
=============================================================

作成した Dockerfileをビルドしてイメージを作成します。

バージョニングを意識してコンテナイメージを作成します、コンテナイメージに明示的にバージョンを指定します。 ::

    $ docker build -t 生成するコンテナイメージ名:タグ名 Dockerファイルのパス

Dockerイメージの生成方法は複数の手法があります。
例えば、普通のOSイメージを起動して、ログインしパッケージなどのインストールを行っていく手法があります。
メリットとしてはオペレーションで作成したものをイメージとして登録できるため、Dockerfileを作成しなくても良いといメリットがある一方で、
コンテナイメージの作成方法が不透明となる可能性もあります。

イメージレポジトリに登録
=============================================================

プライベートレジストリ、DockerHubは選択いただけます。
このラボで作成たイメージを自社などで作成したい場合はDockerHubにpushすることもできます。

DockerHub を使う場合
-------------------------------------------------------------

DockerHubにアカウントがあることが前提です。 ::

    $ docker login
    $ docker image push アカウント名/コンテナイメージ名:タグ名

private registry を使う場合
-------------------------------------------------------------


プライベートレジストリのIPは以下の通りです。

.. todo:: IPアドレス確認。そもそもここに記載するかは検討が必要。

* registry ip: 192.168.1.XX

レジストリは共通に準備しているので、Docker imageをpushする際にレジストリのIPを指定してください。 ::

    $ docker push レジストリIP:ポート/アカウント名/コンテナイメージ名:タグ名



作成したアプリケーションをyamlで定義してデプロイ
=============================================================


:doc:`../Level0/index` ではコマンドラインで作成してきましたがyamlファイルで１サービスをまとめてデプロイ出来るようにします。

ファイルのセクション構成としては以下の通りです。

* Service
* PersistentVolumeClaim
* Deployment

サンプルファイルを準備しましたのでそれぞれの項目の意味を考え作成してみましょう。

(https://kubernetes.io/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/ を参考としています。）


.. todo:: NodePortの書き方を追加するか否か


.. literalinclude:: resources/sample-deployment.yaml
    :language: yaml
    :caption: アプリケーションをデプロイする定義ファイルの例 deployment.yaml


.. caution:: 本番運用に関して
    :doc:`../Level4/index` にてシングル構成ではなく本番運用する際の考慮点等をまとめました。
    Workload APIを使う方法で可用性を高めることができます。

kubectlの操作を容易にする
-------------------------------------------------------------

kubectlのオペレーションの簡易化のためlabelをつけることをおすすめします。

* 参考URL: `k8s label <https://kubernetes.io/docs/concepts/configuration/overview/#using-labels>`_

``kubectl get pods -l app=nginx`` などのようにlabelがついているPod一覧を取得といったことが簡単にできます。
ほかにも以下の様なことが可能となります。

* ``kubectl delete deployment -l app=app_label``
* ``kubectl delete service -l app=app_label``
* ``kubectl delete pvc -l app=wordpress``

以下のコマンドを実行してデプロイしましょう。 ::

    $ kubectl create -f deployment.yaml


アプリケーションの稼働確認
=============================================================

デプロイしたアプリケーションにアクセスし正常稼働しているか確認します。

アクセスするIPについてはサービスを取得して確認します。 ::

    $ kubectl get svc

結果として以下のような出力が得られます。EXTERNAL-IPの項目に表示されているIPにアクセスしてみましょう。 ::

    NAME              TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
    kubernetes        ClusterIP      10.51.240.1    <none>        443/TCP          4d
    wordpress         LoadBalancer   10.51.244.29   <pending>     8080:31658/TCP   41s
    wordpress-mysql   ClusterIP      None           <none>        3306/TCP         52s

まとめ
=============================================================

kubectlやyamlを使ってk8sへのデプロイが体感できたかと思います。
実運用になるとこのyamlをたくさん書くことは負荷になることもあるかもしれません
その解決のためにパッケージマネージャーHelm 等を使ってデプロイすることが多いかと思います。
このラボでは仕組みを理解していただき、応用出来ることを目的としています。

ここまでで Level1 は終了です。