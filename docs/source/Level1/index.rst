==============================================================
Level1: アプリケーションをコンテナ化する
==============================================================

今回はコンテナに適したアーキテクチャに変更するまえの段階として、
オンプレミスで仮想マシンで動いているアプリケーションについてコンテナ化をしていきます。


コンテナ化の準備
=============================================================


本ラボでは以下のイメージを準備しています。

* nginx
* apache
* tomcat

Database レイヤー

* mySQL
* Postgress
* Oracle
* MongoDB

コンテナイメージの作成
=============================================================

想定するアプリケーションのコンテナイメージを作成する。

留意点としては以下の通り

* アプリケーションの配置
* 静的な構成となっていないか？(IPパスワードのべた書きなど）
* Dockerfileの記述
* ステートフルなものについてはコンテナに適したものにする
  * Hint: https://12factor.net/ja/
* 基本となるコンテナイメージについては DockerHub で探してベースイメージとする

Dockerfile のリファレンス `Dockerfile Reference ファイル <https://docs.docker.com/engine/reference/builder/>` _

Hint: どうしても進まない場合は `こちら <src/dockerized.rst>`_ をクリック

コンテナイメージのビルド
=============================================================

作成した Dockerfileをビルドしてイメージを作成する。

バージョニングを意識してい実施する。

- docker built -t **** ****

イメージレポジトリに登録
=============================================================

original or DockerHubは選択いただけます・

DockerHub を使う場合
-------------------------------------------------------------

- docker commit
- docker push

private registry を使う場合
-------------------------------------------------------------

registry ip: 192.168.0.10

- docker commit
- docker push

kubernetes にデプロイ
=============================================================

kubernetes クラスタにデプロイするために、

yaml ファイルを作成する。

サンプル::

    apiversion: 1.0






(Option) Workload API を使えるようであれば使いましょう。

例えば、Webサーバのコンテナは常に２つ立ち上がっている状態、等の定義ができます。


アプリケーションの稼働確認
=============================================================

デプロイしたアプリケーションにアクセスし、正常稼働しているか確認する。

アクセスするIPについては Serviceを定義


ここまでで Level1 は終了です。
