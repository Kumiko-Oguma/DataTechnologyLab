==============================================================
Level 3: CI／CDパイプラインを構築
==============================================================


目的・ゴール: コンテナ化したアプリケーションのCICDを実現する
=============================================================

アプリケーションをコンテナ化したら、常にリリース可能な状態、自動でデプロイメントを出来る仕組みをつくるのが迅速な開発をするために必要になります。

そのためのCI/CDパイプラインを作成するのがこのレベルの目標です。

.. image:: resources/cicd_pipeline.png


本ラボでは Level1, Level2 で行ったオペレーションをベースにCI/CDパイプラインを構築します。

Gitにソースがコミットされたら自動でテスト・ビルドを実現するためのツール(Jenkins)をkubernetes上へデプロイ、及び外部公開をします。
そして、Jenkinsがデプロイできたら実際にアプリケーションの変更を行い自動でデプロイするところまでを目指します。

流れ
=============================================================

#. Jenkins をインストールする
#. Jenkins 内部でジョブを定義する。
#. あるアクションをトリガーにビルド、テストを自動実行する。
#. 自動でk8sクラスタにデプロイメントできるようにする。

CI/CDパイプラインの定義
=============================================================

このラボでのCI/CDパイプラインの定義は以下を想定しています。

* テスト実行
* アプリケーションビルド
* コンテナイメージのビルド
* レジストリへコンテナイメージのpush
* k8sへアプリケーションデプロイ

Gitは共有で準備しています。

ここではJenkinsをkubernetes上にデプロイしてみましょう。
Git自体も併せてデプロイしてみたいということであればGitLabをデプロイすることをおすすめします。
GitLabを使えばコンテナのCI/CDパイプライン、構成管理、イメージレジストリを兼ねて使用することができます。


Jenkinsのデプロイ方法について
=============================================================

CI/CDパイプラインを実現するためのツールとしてJenkinsが非常に有名であることは周知の事実です。
このラボではJenkinsを使用しCI/CDを実現します。

まずは、各自Jenkinsをデプロイします。

方法としては3つ存在します。

#. Helm Chartでデプロイする方法 (手軽にインストールしたい人向け)
#. Level1,2と同じようにyamlファイルを作成し、デプロイする方法(仕組みをより深く知りたい人向け)
#. Kubernetes用にCI/CDを提供するJenkins Xをデプロイする方法(新しい物を使いたい人向け)

今回は最初のHelmでデプロイするバージョンを記載しました。
好みのもの、挑戦したい内容に沿って選択してください。

オリジナルでyamlファイルを作成する場合は以下のサイトが参考になります。

    https://cloud.google.com/solutions/jenkins-on-kubernetes-engine

Helmを使ってJenkinsをデプロイ
=============================================================

.. include:: helm-install.rst

Helm以外でJenkinsをデプロイした場合
=============================================================

本セクションに記載してあることはオプションです。

必要に応じて実施してください。

外部にアプリケーションを公開する方法として ``Ingress`` があります。
Helmを使ってJenkinsをインストールした場合は自動でIngressが作成されます。
それ以外の手法を取った場合は、kubernetesクラスタ外のネットワークからアクセスできるようにIngressを作成してみましょう。


.. raw:: html

    <span style="color: red;font-size: 15px">
    注意 <br/>
    Helm chart を使ってインストールした場合は自動でIngressが導入されています。<br/>
    そのため、以下の手順はHelmで実施した人は不要です。
    </span>



Ingressの導入についてはこちらに :doc:`ingress` まとめました。

ServiceをDNSへ登録する
==============================================================

HelmでデプロイしたJenkinsにはIngress経由でアクセスします。
そのためホスト名を使用してアクセスします。

.. note::
        なぜそのような仕組みになっているかを知りたい方はJenkinsのHelmチャートをご確認ください。
        https://github.com/kubernetes/charts/tree/master/stable/jenkins


今回は名前解決にConsulを使います。

登録用JSONは以下の通りです、TagsとNameでdnsに問い合わせる名前が決まります。
今回はドメインを ``service.consul`` を使用します。

このラボでは命名規則を定義します。

* ID, Tags: アプリケーション識別子.環境番号
* Name: web固定
* Address: 各環境のマスタのIP

アプリケーションにアクセスする際に ``jenkins.user10.web.service.consul`` というFQDNでアクセスしたい場合は以下のjsonファイルを作成します。
ファイル名はwebservice.jsonとします。ポート番号はアプリケーションで使用しているものに変更してください。

.. code-block:: console

        {

          "ID": "jenkins.user10",
          "Name": "web",
          "Tags": [ "jenkins.user10" ],
          "Address": "192.168.XX.10",
          "Port": 80
        }



ファイルを作成したら以下のコマンドで登録します。

.. code-block:: console

        $ curl -i -s --request PUT --data @webservice.json http://infra1:8500/v1/agent/service/register

        HTTP/1.1 200 OK
        Date: Wed, 11 Apr 2018 05:31:37 GMT
        Content-Length: 0
        Content-Type: text/plain; charset=utf-8

登録が完了したら名前解決ができるか確認します。

.. code-block:: console:

        $ nslookup jenkins.user10.web.service.consul

Jenkinsの設定をする
=============================================================

Gitリポジトリに変更があったら自動でテストを実行するジョブを定義します。
このテストは任意で作成してください。

ここでやりたいことは該当リポジトリにコミットがあり、リリースタグが付与された場合に自動でビルド・デプロイをする流れを作成することです。
そのためにはまずJenkinsでGitリポジトリに操作があった場合の動作を定義します。

定義出来る動作としては以下の単位が考えられます。
細かく設定することも可能です。運用に合わせた単位で設定します。

* pull request 単位
* release tag 単位
* 定期実行

前述した以下の項目を盛り込みCI/CDパイプラインを作成しましょう。
以下のようなタスクを組み込んだパイプラインを作成します。シンプルなパイプラインからはじめ、必要に応じてステージを追加していきましょう。


* テスト実行
* アプリケーションビルド
* コンテナイメージのビルド
* レジストリへコンテナイメージのpush
* アプリケーションデプロイ

上記のようなパイプラインを作成にはJenkins pipeline機能が活用できます。

-  https://jenkins.io/doc/book/pipeline/

アプリケーションの変更を検知してデプロイメント可能にする
=============================================================

CI/CDのパイプラインを作成したら実際にアプリケーションの変更をトリガーに(ソースコードの変更、Gitリポジトリへのpush等)k8sへアプリケーションをデプロイします。

ポリシーとして大きく2つに別れます、参考までに以下に記載いたします。

* デプロイ可能な状態までにし、最後のデプロイメントは人が実施する（クリックするだけ）
* デプロイメントまでを完全自動化する

実際にkubernetes環境へのデプロイができたかの確認とアプリケーションが稼働しているかを確認します。

Helm ChartでCI/CD
=============================================================

個別のアプリケーションデプロイメントからHelm Chartを使ったデプロイメントに変更します。

作成したコンテナをHelm Chartを使ってデプロイするようにします。

Helm Chartの開発ガイドは以下のURLを確認ください。

- https://docs.helm.sh/chart_template_guide/#the-chart-template-developer-s-guide


デプロイメントのさらなる進化
=============================================================

CI/CDプロセスを成熟させていくと常にリリース可能な状態となっていきます。
そのような状態になると本番環境へのデプロイを迅速にし、ダウンタイムを最小化するための方法が必要になってきます。
元々存在するプラクティスや考え方となりますがコンテナ技術、kubernetesのスケジューラー機能を使うことで今までの環境とくらべて実現がしやすくなっています。

Blue/Greenデプロイメント, Canary リリースというキーワードで紹介したいと思います。

.. tips::

    CDには２つの意味を含んでいるケースがあります。文脈に応じて見分けるか、どちらの意味か確認しましょう。

    * Continuous Deployment: 常にデプロイ可能なものを生成するまでを自動化する、最後のデプロイメントは手動で実施。
    * Continuous Delivery: 本番環境へのデプロイメントまでを自動化する。

Blue/Greenデプロイメント
-------------------------------------------------------------

従来のやり方では1つの環境にデプロイし何かあれば戻すという方法をほとんどのケースで採用していたかと思いますが、さらなる進化として常に戻せる環境を準備し迅速にロールバック
新バージョン、旧バージョンをデプロイしたままルータで切り替えるようになります。

様々な企業で行き着いている運用でもあるかと思いますが、2010年にBlueGreenデプロイメントという名称で説明しています。

- https://martinfowler.com/bliki/BlueGreenDeployment.html

実現方法、切り替えのタイミングなどあり、BlueGreenの実装の決定的なものはなく、1つのプラクティスとして存在しています。

2つの環境を準備し、どこかのタイミングで切り替えを行うためDBのマイグレーションの方法などを検討する必要はでてきます。

Canary
-------------------------------------------------------------

Canary リリースは BlueGreen デプロイメントと類似したデプロイメントになります。
Blue／Green デプロイメントはすぐに古いバージョンにもどせるように仕組みを整えたものですが、Canaryリリースは新しいバージョン、旧バージョンにアクセスする比率を決めてデプロイするプラクティスです。

こちらは2つの環境ではなく、1環境に複数バージョンのアプリケーションが存在することになります。そのためDBのデータをどのように取り扱うかは検討が必要となります。


まとめ
=============================================================

このラボではコンテナ化したアプリケーションのCI/CDパイプラインの構築に挑戦しました。
CI/CDパイプラインを作成するためのJenkins/GitLabをインストールするために必要なHelmの使い方、アプリケーションを外部に公開するためのkubernetesオブジェクトのIngressも併せて使えるようになりました。

ここまでで Level3 は終了です。
