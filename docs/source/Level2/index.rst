==============================================================
Level 2: ステートフルコンテナの実現
==============================================================

ここではデータの永続化について確認します。
コンテナのホストが変わったり、そもそも永続化をしていないため再起動でデータが消えるをどのように解決するかを見ます。

Dynamic storage provisioningの機構や、PV/PVCについての理解を深めるレベルです。

このレベルで習得できるもの
=============================================================

* PersistentVolumeClaimの使い方
* StorageClassの使い方
* 各種オプション指定時の動作の振る舞い

コンテナでの永続データのカテゴライズ
=============================================================

コンテナ化されたアプリケーション、環境での永続データは以下のように分類して考え必要な物をリストアップします。
このラボで必要なものをリストアップしてみましょう。

コンテナで永続化が必要なものをリストアップする
=============================================================

本ラボでは以下のイメージを準備しています。
考えられるものとしては以下のようなものがあります。

* データベースのデータファイル、ログファイル
* 各サーバのログファイル
* 設定ファイル
* 共有ファイル

NetApp Trident のインストール
=============================================================

ここではネットアップをバックエンドストレージとして使用するために、NetApp Trident を導入します。
TridentはPodとしてデプロイされ通常のアプリケーションと同様に稼働します。

.. include:: trident-install.rst

.. todo:: 設計方針について,絵を追加

StorageClassの定義
=============================================================

StorageClass を定義して、ストレージのサービスカタログを作りましょう。

* DB 用の高速領域: SSD を使ったストレージサービス
* Web コンテンツ用のリポジトリ: HDDを使ったストレージサービス

現在のストレージ構成は以下の通りです。

.. todo:: ストレージの構成を記述(設計する) 各SVMにアグリゲートをHDD, SSDを構成する。


ストレージクラスの作成方法のサンプルは以下の通りです。


.. literalinclude:: resources/sample-sc.yaml
    :language: yaml
    :caption: 高速ストレージ用の定義ファイルの例 StorageClassFastest.yml

ストレージクラスを作成します。 ::

    $ kubectl create -f StorageClassFastest.yml
    storageclass "ontap-gold" created
    $ kubectl get sc
    NAME         PROVISIONER         AGE
    ontap-gold   netapp.io/trident   10s

Persistent Volume Claimの作成
=============================================================

アプリケーションで必要とされる永続化領域の定義をします。


デプロイに使用したyamlファイルに PVC を追加
=============================================================

Level1 のときに作成した yaml に PVC の項目を追加し、永続化出来るアプリケーションを定義します。

.. literalinclude:: resources/sample-pvc.yaml
    :language: yaml
    :caption: 高速ストレージ用の定義ファイルの例 PVCFastest.yml

デプロイメント実施
=============================================================

アプリケーションから何かしらのデータを保存するようにします。

例:

    * アプリケーションからデータを記録
    * シンプルにnginxのアクセスログファイルを永続化

アプリケーションの停止
=============================================================

永続化されていることを確認するため、一度アプリケーションを停止します。
可能であればアプリケーションのバージョンアップを行う。

簡単に実施するのはDeploymentで必ず１つのポッドは起動するような設定になっているため、
ポッド自体を削除すると新たにポッドが起動します。


再デプロイメント
=============================================================

再起動したPodに対してボリュームがマウントされていることを確認することも可能です。
容易に行える操作としてはDeployment配下にあるPodを削除し、Deploymentによって起動し直させるといったやり方です。

* アプリケーションであれば再度ログインし、保存したデータを確認します。

* 通常運用のリリースに想定するオペレーションをして、外部ストレージにデータ永続化されていることを確認します。

動的にボリュームが作成されていることを確認します。 ::


    $ ssh admin@192.168.20.20 vol show -vserver tridentsvm
    Password:
    Vserver   Volume       Aggregate    State      Type       Size  Available Used%
    --------- ------------ ------------ ---------- ---- ---------- ---------- -----
    tridentsvm root        aggr1        online     RW          1GB    972.2MB    5%
    tridentsvm trident_trident aggr1    online     RW       1.86GB     1.77GB    5%
    tridentsvm trident_trident_basic_f4048 aggr1 online RW     1GB    972.4MB    5%
    3 entries were displayed.



まとめ
=============================================================

本ラボではアプリケーションに対してデータの永続化を施しました。
今回はStorageClassの作成からアプリケーションにPersistentVolumeを割り当てるところまでを一連の流れで体験しました。
本来であれば、それぞれで役割がことなるため以下のような分担になるかと思います。

    * StorageClassの作成: インフラの管理者
    * PersistentVolumeClaimの作成: 利用者

動的にストレージをプロビジョニングし、ポッドに割り当てる方法について体験しました。
今後障害時の動作が気になると思いますが、 :doc:`../Level4/index` での検討事項とします。

ここまでで Level2 は終了です。
